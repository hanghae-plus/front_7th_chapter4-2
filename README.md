# 과제 체크포인트
[배포주소](https://parksubeom.github.io/front_7th_chapter4-2/)
## 과제 요구사항

- [x] 배포 후 url 제출

- [x] API 호출 최적화(`Promise.all` 이해)긴

- [x] SearchDialog 불필요한 연산 최적화
- [x] SearchDialog 불필요한 리렌더링 최적화

- [x] 시간표 블록 드래그시 렌더링 최적화
- [x] 시간표 블록 드롭시 렌더링 최적화

## 과제 셀프회고

<details>
<summary><h2>1일차 : 검색 다이얼로그(SearchDialog) 최적화</h2></summary>

## 성능 개선: API 호출 병렬화 및 중복 제거

### 1. 문제 분석
- **직렬 처리:** `Promise.all` 내부에 `await` 키워드를 사용하여 API가 순차적으로 호출됨. 앞선 요청이 끝나야 다음 요청이 시작되는 비효율적인 대기 시간 발생.
- **불필요한 중복 호출:** 동일한 리소스(`fetchMajors`, `fetchLiberalArts`)를 3번씩 중복 호출하여 총 6번의 불필요한 네트워크 트래픽 발생.
- **영향:** 메인 콘텐츠 렌더링(LCP)이 API 응답 시간의 총합만큼 지연됨 (LCP: 2.89s 측정).

### 2. 코드 변경 사항

**변경 전**
```typescript
// 현재 코드: await를 만나서 API 1번 끝나야 2번 호출 (순차적)
const fetchAllLectures = async () => await Promise.all([
  (console.log('API Call 1', performance.now()), await fetchMajors()),
  (console.log('API Call 2', performance.now()), await fetchLiberalArts()),
  // ... 반복 (총 6번 호출) ...
]);
```

**변경 후**
```typescript
// 수정된 fetchAllLectures: 불필요한 중복 제거 및 병렬 호출
const fetchAllLectures = async () => {
  const start = performance.now();
  console.log('API 호출 시작: ', start);

  // 1. Promise 객체를 먼저 생성 (호출 시작)
  const majorsPromise = fetchMajors();
  const liberalArtsPromise = fetchLiberalArts();

  // 2. Promise.all로 두 요청이 모두 끝날 때까지 병렬 대기
  const results = await Promise.all([
    majorsPromise,
    liberalArtsPromise
  ]);

  // ... 로그 출력 ...
  return results;
};
```

### 3. 개선 방안
- **병렬 처리:** 프로미스를 즉시 실행시키고, `Promise.all`로 동시에 대기하여 전체 소요 시간을 가장 느린 요청 하나의 시간으로 단축.
- **중복 제거:** 실제 필요한 `전공`과 `교양` 데이터만 1회씩 호출.

### 4. 개선 근거
- **자바스크립트 비동기 처리:** 네트워크 대기 시간 동안 메인 스레드를 차단하지 않고 병렬로 요청을 처리하는 자바스크립트의 특성을 활용.
- **리소스 효율성:** 불필요한 네트워크 대역폭 낭비를 줄이고, 클라이언트의 메모리 사용량을 최적화함.

### 5. 예상 효과
- 네트워크 순차 대기 현상 제거로 초기 로딩 속도 획기적 단축 예상.
- 중복 호출 제거로 서버 부하 감소 및 사용자 경험 개선.

---

## 성능 개선: 검색 필터링 연산 메모이제이션

### 1. 문제 분석
- **불필요한 재연산:** `SearchDialog` 컴포넌트 내 `getFilteredLectures` 함수가 컴포넌트 리렌더링(입력, 스크롤 등)이 발생할 때마다 매번 실행됨.
- **비용 높은 로직:** 수천 개의 강의 데이터를 대상으로 필터링, 포함 여부 확인, 문자열 파싱 같은 무거운 연산을 반복 수행.
- **영향:** 검색어를 한 글자 입력할 때마다 메인 스레드가 필터링 연산에 점유되어, 입력 지연 현상이 발생함.

### 2. 코드 변경 사항

**변경 전**
```typescript
// 렌더링될 때마다 매번 실행됨
const getFilteredLectures = () => {
  const { query = '', credits, ... } = searchOptions;
  return lectures
    .filter(lecture => ...)
    // ... 수천 번의 루프와 파싱 작업 ...
}
const filteredLectures = getFilteredLectures();
```

**변경 후**
```typescript
import { useMemo } from 'react';

// 의존성 배열(searchOptions, lectures)이 변할 때만 재계산
const filteredLectures = useMemo(() => {
  const { query = '', credits, ... } = searchOptions;
  return lectures
    .filter(lecture => ...)
    // ... (동일한 로직) ...
}, [searchOptions, lectures]);
```

### 3. 개선 방안
- **메모이제이션 적용:** `useMemo` 훅을 사용하여 검색 옵션이나 강의 데이터가 실제로 변경되었을 때만 필터링 로직을 수행하도록 변경.
- **참조 안정성:** 필터링 결과 배열의 참조값을 유지하여, 하위 컴포넌트의 불필요한 리렌더링 방지 효과도 부수적으로 기대함.

### 4. 개선 근거
- **연산 비용 절감:** 문자열 파싱과 대량의 배열 순회는 자바스크립트 메인 스레드에 부담을 주는 작업이므로, 입력과 같은 빈번한 이벤트 시에는 캐싱이 필수적임.
- **이벤트 루프 차단 방지:** 필터링 연산이 길어지면 메인 스레드가 차단되어 사용자 입력에 대한 반응이 지연되고, INP 점수가 하락함.

### 5. 예상 효과
- 검색어 입력 시 발생하는 렉 현상 제거 및 반응성 지표 개선.
- 메인 스레드 부하 감소로 전반적인 UI 반응성 향상.

---

## 성능개선: 검색 필터 UI 분리 및 불필요한 리렌더링 방지

### 1. 문제 분석
- **전체 리렌더링 문제:** 무한 스크롤 동작 시 페이지 상태가 변경되면, 상위 컴포넌트인 `SearchDialog` 전체가 리렌더링되는 구조.
- **불필요한 렌더링:** 변경 사항이 없는 검색 옵션 영역(입력창, 체크박스 등)까지 매번 재생성되어 자원을 낭비함.
- **고비용 연산 반복:** 전공 목록 생성 로직과 같은 연산이 렌더링마다 반복 수행됨.

### 2. 코드 변경 사항

**(변경 전)** `SearchDialog` 내부에 필터 UI가 결합되어 있어 페이지 변경 시 같이 렌더링됨.
<img width="840" height="700" alt="image" src="https://github.com/user-attachments/assets/67f4cb51-da9a-44ff-ba4b-90ef7d84f8e4" />

```tsx
const SearchDialog = () => {
  const [page, setPage] = useState(1);
   
  // 렌더링마다 매번 재연산
  const allMajors = [...new Set(lectures.map(...))];
  const changeSearchOption = (...) => { ... }; // 매번 새로운 참조 생성

  return (
      {/* SearchDialog 내부에 필터 UI가 결합되어 있어 page 변경 시 같이 렌더링됨 */}
      ...
  );
}
```

**(변경 후)**
<img width="840" height="750" alt="image" src="https://github.com/user-attachments/assets/b39eb5df-62a5-4ee2-bdbc-057742fff5d6" />

```tsx
// 1. 별도 컴포넌트로 분리 및 React.memo 적용
const SearchFilter = memo(({ searchOptions, changeSearchOption, allMajors }) => {
  return ...;
});

const SearchDialog = () => {
  // 2. 데이터 연산 최적화 (참조 안정화)
  const allMajors = useMemo(() => [...], [lectures]);
  
  // 3. 핸들러 최적화
  const changeSearchOption = useCallback((...) => { ... }, []);

  return (
      {/* 페이지가 변해도 props가 동일하므로 리렌더링 건너뜀 */}
      <SearchFilter ... />
      ...
  );
}
```

### 3. 개선 방안
- **컴포넌트 분리:** 복잡하고 정적인 검색 필터 UI를 별도 컴포넌트로 분리하여 렌더링 경계를 격리.
- **React.memo 적용:** 분리된 컴포넌트에 메모이제이션을 적용하여 전달받은 값이 변경되지 않는 한 리렌더링을 방지.
- **참조 안정성 확보:** `useMemo`와 `useCallback`을 사용하여 하위 컴포넌트에 안정적인 참조를 전달.

### 4. 개선 근거
- **렌더링 성능:** 무한 스크롤과 같이 빈번하게 상태가 변하는 로직과 정적인 UI를 분리함으로써, 브라우저의 그리기 부하를 줄이고 화면 끊김을 방지.
- **관심사의 분리:** UI와 비즈니스 로직의 결합도를 낮춰 유지보수성을 향상.
- **참조 동일성 활용:** React는 값 비교 시 참조 동일성을 사용하므로, 참조를 안정화하면 `React.memo`의 효과를 극대화할 수 있음.

### 5. 예상 효과
- 스크롤 시 검색 필터 영역의 불필요한 리렌더링이 0회로 감소.
- 복잡한 컴포넌트 구조 단순화로 가독성 및 유지보수성 증대.
- 메인 스레드 부하 감소로 전반적인 스크롤 성능 향상.

---

## 문제 수정: 콜백 Ref 패턴으로 무한 스크롤 초기화 타이밍 이슈 해결

### 1. 문제 분석
- **타이밍 문제:** 모달의 렌더링 특성상, `useEffect`가 최초 실행되는 시점에 관찰 대상인 DOM 요소가 아직 생성되지 않아 `null`인 경우가 발생.
- **감지되지 않는 업데이트:** 이후 DOM이 생성되어 참조값이 채워지더라도, `useRef`는 리렌더링을 유발하지 않으므로 `useEffect`가 이를 인지하지 못하고 옵저버 연결이 누락됨.
- **영향:** 모달을 처음 열거나 특정 조건에서 무한 스크롤이 작동하지 않는 버그 발생.

### 2. 코드 변경 사항

**변경 전**
```tsx
const loaderRef = useRef(null); // 변화 감지 불가
useEffect(() => {
  if (!loaderRef.current) return; // 실행 시점에 null이면 그냥 종료됨
}, [searchInfo]);
```

**변경 후**
```tsx
const [loader, setLoader] = useState(null); // DOM 생성 시 리렌더링 트리거
useEffect(() => {
  if (!loader) return; // loader 상태가 업데이트되면 다시 실행됨
}, [loader]); 

// JSX: ref 속성에 상태 설정 함수 전달
<Box ref={setLoader} ... />
```

### 3. 해결 방안
- **콜백 Ref 패턴:** `useRef` 대신 `useState`를 사용하여 DOM 요소의 생성/소멸 생명주기를 상태로 관리.
- **반응형 옵저버:** DOM 요소가 실제로 화면에 그려지는 시점에 상태가 업데이트되도록 하여, `IntersectionObserver`가 누락 없이 연결되도록 보장.

### 4. 개선 근거
- **React 생명주기:** `useRef`는 값이 변경되어도 컴포넌트를 다시 그리지 않지만, `useState`는 상태 변경 시 다시 그리기를 유발하므로 변화를 감지할 수 있음.
- **콜백 Ref:** JSX의 `ref` 속성에 함수를 전달하면, DOM이 생성될 때 해당 함수가 호출되어 정확한 타이밍에 상태를 업데이트할 수 있음.

### 5. 예상 효과
- 모달을 처음 열 때, 새로고침 할 때 등 모든 상황에서 무한 스크롤 기능이 안정적으로 동작함.
- 옵저버 연결 실패로 인한 버그가 완전히 제거됨.

---

## 성능 개선: API 호출 시점 지연

### 1. 문제 분석
* **이른 데이터 호출:** 컴포넌트가 화면에 나타남과 동시에 대용량 데이터를 즉시 호출함.
* **리소스 경합:** 페이지 초기 로딩 구간에서 불필요한 네트워크 대역폭과 자원을 점유하여, 주요 콘텐츠 렌더링 성능 저하를 유발함.
* **사용자 의도 불일치:** 사용자가 검색 버튼을 누르기 전까지는 해당 데이터가 필요하지 않음에도 미리 요청이 발생함.

### 2. 코드 변경 사항

**변경 전**
<img width="312" height="236" alt="image" src="https://github.com/user-attachments/assets/813a97ad-fe48-4bcc-a1d8-61ec29e85219" />

```tsx
useEffect(() => {
  // 컴포넌트 마운트 시 무조건 실행
  fetchAllLectures().then(...);
}, []);
```

**변경 후**
<img width="312" height="236" alt="image" src="https://github.com/user-attachments/assets/9000597b-bd6c-47b0-a081-b4594f648db1" />

```tsx
useEffect(() => {
  // 모달이 열리지 않았거나 이미 데이터를 가져온 경우 중단
  if (!searchInfo || lectures.length > 0) return;

  // 모달이 열리는 순간 데이터 로딩 시작
  fetchAllLectures().then(...);
}, [searchInfo]);
```

### 3. 해결 방안
* **지연 호출:** 데이터 로딩 시점을 페이지 로드 시점이 아닌 모달이 열리는 시점으로 지연.
* **조건부 호출:** 이미 로드된 데이터가 있을 경우 API 재요청을 방지하는 간단한 캐싱 로직 적용.

### 4. 개선 근거
* **주요 렌더링 경로 최적화:** 초기 렌더링에 필수적이지 않은 네트워크 요청을 미루어 브라우저가 주요 콘텐츠 렌더링에 집중할 수 있도록 함.
* **필요 시점 로딩:** 사용자의 명확한 의도가 발생한 이후에만 리소스를 요청하여 불필요한 트래픽 및 연산 낭비를 제거함.

### 5. 예상 효과
* 초기 페이지 로딩 시 발생하던 네트워크 병목 현상 제거.
* LCP(최대 콘텐츠 렌더링 시간) 지표의 유의미한 개선.
* 사용자 동작 기반 데이터 로딩으로 체감 성능 향상.

---

## 성능 개선: 검색 필터 렌더링 최적화

### 1. 문제 분석
* **렌더링 차단:** 검색어 입력 시 필터 컴포넌트 전체가 다시 그려짐.
* **무거운 가상 DOM 생성:** 텍스트 한 글자를 입력할 때마다 수백 개의 체크박스 가상 DOM이 재생성되며 메인 스레드를 점유, 입력 지연이 발생함.
* **깨진 메모이제이션:** 하위 컴포넌트에 전달되는 이벤트 핸들러가 인라인 함수로 선언되어 렌더링마다 참조값이 변경되고, 이로 인해 `React.memo`가 작동하지 않음.

### 2. 코드 변경 사항

**변경 전**
<img width="1000" height="740" alt="image" src="https://github.com/user-attachments/assets/a61d7692-ae9f-4a57-b021-95945ee5f4ff" />

```tsx
const SearchFilter = memo(({ searchOptions, ... }) => {
  // 1. 거대한 단일 컴포넌트
  // 2. 인라인 핸들러로 인해 매 렌더마다 새로운 함수 생성
  return (
    <Stack>
      <Input ... />
      <CheckboxGroup onChange={(v) => changeSearchOption("majors", v)}>
        {/* 수백 개의 전공 리스트가 매번 재생성됨 */}
      </CheckboxGroup>
    </Stack>
  );
});
```

**변경 후**
<img width="1000" height="740" alt="image" src="https://github.com/user-attachments/assets/81975216-83ff-4eeb-a32f-c5498a53cf5f" />

```tsx
// 1. 컴포넌트 쪼개기 및 메모이제이션
const MajorCheckboxGroup = memo(({ majors, onChange }) => { ... });

const SearchFilter = memo(({ searchOptions, ... }) => {
  // 2. 핸들러 참조 안정화
  const handleChangeMajors = useCallback(
    (v) => changeSearchOption("majors", v),
    []
  );

  return (
    <Stack>
      <Input ... /> {/* 검색어 입력 시 이 부분만 리렌더링 */}
      {/* props가 변경되지 않아 렌더링 건너뜀 */}
      <MajorCheckboxGroup onChange={handleChangeMajors} ... />
    </Stack>
  );
});
```

### 3. 해결 방안
* **컴포넌트 분리:** 비대한 필터 컴포넌트를 작은 단위로 나누고 각각에 `React.memo`를 적용.
* **핸들러 안정화:** `useCallback`을 사용해 이벤트 핸들러의 참조값을 고정하여, 불필요한 리렌더링을 원천 차단.

### 4. 개선 근거
* **참조 동일성:** React의 최적화는 값의 참조 동일성에 의존하므로, 핸들러를 안정화해야 `React.memo`가 효과를 발휘함.
* **렌더링 범위 최소화:** 검색어 입력과 관련 없는 대규모 체크박스 UI를 렌더링 경로에서 분리하여 메인 스레드 부하를 줄임.

### 5. 예상 효과
* 검색어 입력 시 CPU 사용량 최소화 및 렌더링 범위 국소화.
* 사용자가 체감하던 입력 지연 현상 완전 제거.

---

## 성능 개선: 데이터 전처리를 통한 필터링 연산 최적화

### 1. 문제 분석
* **반복적인 고비용 연산:** 필터링이 수행될 때마다 수천 개의 강의 객체에 대해 문자열 파싱 로직이 반복 실행됨.
* **반응성 저하:** 문자열 파싱은 비용이 큰 연산으로, 필터링 시마다 메인 스레드를 장시간 점유하여 심각한 입력 지연을 유발함.

### 2. 코드 변경 사항

**변경 전:** 필터링 시마다 파싱 수행 (비용: N × 파싱비용)

**변경 후**
```ts
// 1. 데이터 로드 시 단 1회만 파싱 (전처리)
setLectures(
  data.map((l) => ({
    ...l,
    schedules: l.schedule ? parseSchedule(l.schedule) : [],
  }))
);

// 2. 필터링 시에는 이미 계산된 값만 참조 (비용: N)
.filter((lecture) => lecture.schedules.some(...));
```

### 3. 해결 방안
* **데이터 변환:** API 응답을 수신하는 즉시 문자열을 파싱하여 객체에 미리 저장.
* **전처리 전략:** 계산 비용이 큰 파싱 로직을 빈번한 필터링 단계가 아닌 데이터 로딩 단계로 이동.
* **로직 단순화:** 필터 로직에서 파싱 함수를 제거하고, 미리 계산된 속성만 참조하도록 변경.

### 4. 개선 근거
* **시간 복잡도 최적화:** 사용자 입력 시 수행되는 연산 비용을 구조적으로 축소.
* **렌더링 경로 경량화:** 필터링 로직에서 고비용 연산을 제거하여 메인 스레드 점유를 최소화.
* **전처리 원칙:** "비싼 계산은 렌더링 경로 밖에서 한 번만 수행한다"는 원칙 적용.

### 5. 예상 효과
* 필터링 연산 비용 감소로 검색 및 필터 반응 속도 비약적 향상.
* 데이터 규모가 증가하더라도 성능 저하 없이 확장 가능한 구조 확보.

---

## 성능 개선: 문자열 검색 전처리

### 1. 문제 분석
* **메모리 낭비:** 필터링 로직 내부에서 소문자 변환 함수를 직접 호출함에 따라, 검색어 입력 시마다 수천 개의 임시 문자열 객체가 반복적으로 생성되고 파괴됨.
* **가비지 컬렉션 부하:** 빈번한 메모리 할당과 해제는 브라우저의 가비지 컬렉터를 자극하여 메인 스레드를 일시적으로 멈추게 함.
* **입력 지연:** 가비지 컬렉션 개입 시점이 사용자 입력과 겹치면서 입력 반응성이 저하됨.

### 2. 코드 변경 사항

**변경 전:** 매 필터링 루프마다 문자열 변환 및 메모리 할당 발생.

**변경 후**
```ts
// 1. 데이터 로드 시 단 1회만 문자열 전처리
const titleLower = lecture.title.toLowerCase();

// 2. 필터링 시에는 변환 없이 비교만 수행 (객체 생성 없음)
.filter((lecture) => lecture.titleLower.includes(queryLower));
```

### 3. 해결 방안
* **데이터 구조 확장:** 강의 객체에 검색 전용 필드를 추가.
* **사전 계산:** 데이터 로딩 시점에 문자열 변환을 1회만 수행.
* **객체 생성 방지:** 필터링 시점에서는 변환 함수 호출을 제거하고, 이미 처리된 문자열 간 비교만 수행.

### 4. 개선 근거
* **객체 생성 최소화 전략:** 성능에 민감한 루프 내부에서 객체 생성을 제거하여 메모리 압력을 감소.
* **관심사의 분리:** 데이터 가공은 로딩 시점에, 비교는 인터랙션 시점에 수행하여 사용자 입력 경로에는 저비용 연산만 남김.

### 5. 예상 효과
* 검색 시 메모리 사용량 그래프의 급격한 변동 제거 및 안정화.
* 빠른 연속 타이핑 상황에서도 끊김 없는 부드러운 입력 반응성 확보.

---

## 성능개선: 필터링 로직의 가독성 및 연산 효율 개선

### 1. 문제 분석
* **높은 복잡도:** 여러 조건이 하나의 긴 표현식으로 결합되어 있어 로직 파악이 어려움.
* **디버깅 어려움:** 필터 결과가 예상과 다를 경우, 어떤 조건에서 문제가 발생했는지 추적하기 어려움.
* **실행 효율 한계:** 모든 조건이 하나로 묶여 있어 실행 순서 제어 및 비용 기반 최적화가 어려움.

### 2. 코드 변경 사항

**변경 전:** 모든 조건이 하나의 `return` 문에 결합된 구조.

**변경 후:** 조건을 개별적으로 검사하고, 불만족 시 즉시 종료하는 구조.
```js
if (queryLower && !lecture.titleLower.includes(queryLower)) return false;
if (grades.length > 0 && !grades.includes(lecture.grade)) return false;
// ...
return true;
```

### 3. 해결 방안
* **보호 구문 패턴 도입:** 조건을 만족하지 않는 경우를 `if` 문으로 즉시 반환하여 불필요한 연산을 조기에 차단.
* **순차적 검증:** 필터 조건을 논리적 단위로 분리하고, 위에서 아래로 흐르는 선형적인 구조로 변경.

### 4. 개선 근거
* **단축 평가 최적화:** 앞선 조건에서 탈락하면 뒤쪽의 비용이 큰 연산은 실행하지 않음으로써 CPU 자원을 절약.
* **유지보수성:** 새로운 필터 조건 추가 시 기존 로직을 수정할 필요 없이 구문 하나를 추가하는 방식으로 확장 가능.

### 5. 예상 효과
* **디버깅 속도:** 특정 조건에 로그를 심거나 디버거를 연결하여 즉시 원인 파악 가능.
* **성능:** 필터 조건이 늘어날수록 불필요한 고비용 연산을 조기에 차단하여 성능 방어.
* **코드 품질:** 가독성이 좋아져 팀원 누구나 로직을 빠르게 이해 가능.

---
</details>

<details>
<summary><h2>2일차 : 시간표(ScheduleTable) 및 래퍼(ScheduleTables) 최적화</h2></summary>

## 성능 개선: 컴포넌트 리렌더링 방어 및 메모이제이션

### 1. 문제 분석
- **연쇄적인 렌더링:** 최상위 컴포넌트의 상태가 변경되어 모달이 열릴 때, 데이터 변경과 무관한 하위의 모든 시간표 컴포넌트와 강의 블록이 강제로 다시 그려짐.
- **참조 불안정성:** 이벤트 핸들러 함수가 렌더링마다 새로 생성되어 자식 컴포넌트는 속성이 변경된 것으로 인식함.
- **영향:** 단순한 모달 오픈 동작에도 수십 개의 컴포넌트가 다시 그려지며 UI 반응 속도 저하를 유발함.

### 2. 코드 변경 사항

**변경 전:** 핸들러가 매번 새로 생성되고, 자식 컴포넌트에 방어막이 없음.

**변경 후**
```tsx
// 1. 핸들러 참조 고정
const handleScheduleTimeClick = useCallback((...) => { ... }, []);

// 2. 렌더링 방어막 구축 (값이 같으면 렌더링 건너뜀)
const DraggableSchedule = memo(({ ... }) => { ... },
  (prev, next) => prev.data === next.data && prev.bg === next.bg
);
```

### 3. 개선 방안
- **핸들러 메모이제이션:** `useCallback`을 사용하여 함수의 참조를 고정, 불필요한 변경 감지를 차단.
- **컴포넌트 메모이제이션:** `React.memo`를 사용하여 부모의 렌더링이 자식에게 전파되는 것을 차단.
- **커스텀 비교 함수:** 데이터와 스타일 등 핵심 속성만 비교하는 로직을 적용하여 불필요한 렌더링을 더욱 정밀하게 방지.

### 4. 개선 근거
- **비교 연산 최적화:** 리액트에서 속성 비교 비용이 컴포넌트 실행 비용보다 훨씬 저렴하다는 점을 활용.
- **참조 무결성:** 객체와 함수의 얕은 비교 메커니즘을 이용하여 렌더링 트리의 불필요한 부분을 제거.
- **선택적 렌더링:** 실제로 변경된 데이터만 렌더링하여 불필요한 연산을 원천 차단.

### 5. 예상 효과
- 모달 오픈 시 시간표 컴포넌트들의 불필요한 리렌더링 횟수 0회로 감소.
- 렌더링 차단 해소로 모달 애니메이션 및 반응성 즉각 개선.

---

## 성능 개선: 드래그 앤 드롭 렌더링 격리 및 배경 최적화

### 1. 문제 분석
- **전역 상태로 인한 과도한 리렌더링:** 드래그 상태 관리자가 최상위에 위치하여, 특정 테이블에서 드래그가 시작되면 모든 테이블이 불필요하게 다시 그려짐.
- **정적 요소의 반복 연산:** 드래그 중이거나 데이터가 변경될 때, 변하지 않는 배경 그리드(요일/시간 칸) 수백 개가 매번 다시 그려짐.
- **성능 저하:** 드래그 시 화면 끊김 현상이 발생하고 반응성이 떨어짐.

### 2. 코드 변경 사항

**변경 전:** 전역 상태 관리 및 통합된 그리드 구조.
<img width="750" height="900" alt="image" src="https://github.com/user-attachments/assets/e357db7d-12ed-4bf8-b02c-5c36d59a8d30" />

```tsx
// App.tsx
<ScheduleDndProvider> {/* 전역에서 관리 */}
  <ScheduleTables />
</ScheduleDndProvider>

// ScheduleTable.tsx
// 배경과 컨텐츠가 결합되어 있어 함께 리렌더링됨
const ScheduleTable = memo(({ schedules }) => {
  const dndContext = useDndContext(); // 전역 컨텍스트 구독
  return (
    <Grid>
      {/* 배경 그리기 (매번 실행) */}
      {DAY_LABELS.map(...)} 
      {/* 강의 그리기 */}
      {schedules.map(...)}
    </Grid>
  );
});
```

**변경 후:** 개별 상태 관리 및 컴포넌트 분리.
<img width="750" height="900" alt="image" src="https://github.com/user-attachments/assets/112484bc-10c8-4f77-bdfd-4af9096bbb9a" />

```tsx
// App.tsx
// <ScheduleDndProvider> 제거 (각 테이블이 독립적으로 관리)

// ScheduleTable.tsx
// 1. 정적 배경 분리 (메모이제이션)
const GridBackground = memo(() => <>{/* 배경 렌더링 */}</>);

// 2. 개별 상태 관리 적용
export const ScheduleTable = memo(() => {
  return (
    <DndContext ...> {/* 이 테이블만의 독립된 드래그 컨텍스트 */}
       <GridBackground /> {/* 배경은 렌더링 생략 */}
       {lectures.map(...)} {/* 강의만 렌더링 */}
    </DndContext>
  );
});
```

### 3. 개선 방안
- **렌더링 격리:** 드래그 상태 관리자를 각 테이블 내부로 이동시켜, 이벤트가 다른 테이블로 전파되지 않도록 구조 변경.
- **관심사의 분리:** 변하지 않는 배경과 변하는 강의 데이터를 분리하여 관리.
- **엄격한 타입 정의:** 이벤트 핸들러에 정확한 타입을 명시하여 안정성 확보.

### 4. 개선 근거
- **상태 배치 원칙:** 테이블 간 이동이 없는 로직 상, 상태를 전역에 둘 이유가 없음. 데이터를 사용하는 곳에 상태를 위치시켜 렌더링 범위를 최소화.
- **렌더링 최적화:** 요소가 많은 배경 그리드는 그리기 비용이 높으므로, `React.memo`를 통해 재사용되도록 강제함.

### 5. 예상 효과
- **테이블 간 불필요한 렌더링 제거:** 하나의 테이블을 조작할 때 다른 테이블은 영향을 받지 않음.
- **배경 렌더링 제거:** 데이터가 변경되어도 배경 그리드는 다시 그려지지 않음.
- **프레임 향상:** 드래그 시 메인 스레드 부하가 감소하여 부드러운 움직임 제공.

---
</details>

<details>
<summary><h2>3일차 : 접근성 최적화</h2></summary>

## 접근성 개선: 메인 랜드마크 설정 적용

### 1. 문제 분석
- **접근성 경고 발생:** 진단 도구에서 문서에 주요 랜드마크가 없다는 경고가 지속적으로 발생.
- **탐색성 저하:** 페이지의 핵심 콘텐츠 영역이 모두 의미 없는 태그로 구성되어 있어, 스크린 리더 사용자가 본문 영역을 식별하거나 바로 이동하기 어려움.
- **구조적 의미 부재:** 문서 구조상 주요 콘텐츠 영역이 명확히 정의되지 않음.

### 2. 코드 변경 사항

**변경 전:** 기본 태그인 `div`로 렌더링됨.

**변경 후**
```tsx
// as props를 활용하여 실제 태그를 main으로 변경
<Flex as="main" ...>
  {/* 시간표 목록 */}
</Flex>
```

### 3. 해결 방안
- **시맨틱 마크업 적용:** 스타일 컴포넌트의 속성을 활용하여 실제 문서 구조를 의미론적으로 개선.
- **메인 랜드마크 명시:** 시간표 목록 영역을 페이지의 주요 콘텐츠로 정의하고 `main` 태그를 적용.
- **버튼 명도대비 고대비로 변경:** 기존의 green 컬러의 경우 kwcag 기준에서는 최소 권장사항에 부합하지만, wcag기준으로는 미흡하여 3.5:1 -> 10.5:1 고대비 색상으로 변경

### 4. 개선 근거
- **웹 표준 준수:** 웹 접근성 지침에 따라 페이지의 핵심 콘텐츠는 `main` 랜드마크 내에 포함되어야 함.
- **보조 기술 지원:** 스크린 리더 사용자가 랜드마크 이동 기능을 통해 본문으로 빠르게 접근할 수 있도록 지원.
- **의미 기반 구조:** 단순한 스타일 컨테이너가 아닌, 역할이 명확한 태그 사용으로 문서의 의미 전달력 강화.

### 5. 예상 효과
- **접근성 점수 개선:** 주요 랜드마크 부재 경고 제거.
- **사용자 경험 향상:** 스크린 리더 사용자의 본문 탐색 시간 단축 및 이해도 향상.
- **접근성 기준 충족:** 모든 사용자에게 동등한 콘텐츠 탐색 경험 제공.

---
</details>

### 성능 지표 비교 테이블

| 구분    | 최적화 전               | 최적화 후           |
| ----- | ------------------- | --------------- |
| 측정 시점 | 최적화 적용 이전           | 최적화 적용 이후       |
| 측정 도구 | Lighthouse          | Lighthouse      |
| 측정 대상 | 검색 / 필터링 포함 페이지     | 검색 / 필터링 포함 페이지 |
| 특징    | 초기 렌더링 및 인터랙션 지연 발생 | 렌더링 및 입력 반응성 개선 |
| 정량 지표 | 아래 측정 스크린샷 참조       | 아래 측정 스크린샷 참조   |

> 모든 성능 평가는  Dev tools Lighthouse 측정 결과를 근거로 함

---

### Lighthouse 측정 결과 (Before / After)

| 최적화 전                                                                                                   | 최적화 후                                                                                                   |
| ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| ![최적화 전 Lighthouse 결과](https://github.com/user-attachments/assets/cbf711b0-204e-4de7-bd75-d1fb114e5606) | ![최적화 후 Lighthouse 결과](https://github.com/user-attachments/assets/d6908b52-b295-4744-922e-77394234a723) |

<details>
<summary><h2>트레이드 오프</h2></summary>

이번 과제를 진행하며 필수적인 성능 개선은 마쳤지만, **"데이터가 지금보다 100배 더 많아진다면 어떻게 될까?"** 라는 궁금증이 생겼습니다. 그래서 더 깊은 최적화 방법들을 찾아보았고, 비록 지금 당장 적용하지는 않았지만 앞으로 꼭 도전해보고 싶은 기술들을 정리했습니다.

### 1. 웹 워커 (Web Worker): 연산을 다른 곳에서 처리하기

* **고민의 시작:** "필터링해야 할 강의가 수십만 개라면, 아무리 계산을 효율적으로 해도 화면이 잠깐 멈추지 않을까?"라는 걱정이 들었습니다. 메인 화면이 멈추지 않도록 계산 작업만 따로 수행하는 **웹 워커** 기술을 검토했습니다.
* **비유 및 트레이드오프:**
* 이는 마치 혼자서 요리(화면 렌더링)와 서빙을 다 하던 셰프가, 산더미처럼 쌓인 양파 까기(데이터 계산)를 해야 하는 상황과 같습니다. 셰프가 직접 양파를 까면 손님 응대를 멈춰야 합니다.
* 그래서 **'주방 보조(웹 워커)'** 를 고용하면 셰프는 요리에만 집중할 수 있습니다. 하지만 보조에게 업무를 지시하고 재료를 건네주는 소통 비용이 발생합니다. 현재는 까야 할 양파(데이터)가 많지 않아서, 셰프가 직접 후딱 처리하는 것이 보조를 부르는 것보다 더 효율적이라 판단했습니다.


* **앞으로의 계획:** 나중에 다뤄야 할 데이터가 엄청나게 많아지거나 계산이 매우 복잡해지면, 웹 워커를 도입하여 사용자가 절대 끊김을 느끼지 못하는 환경을 만들어보고 싶습니다.

### 2. 목록 가상화 (Virtualization): 보이는 것만 그리기

* **고민의 시작:** 무한 스크롤로 데이터를 계속 불러오면, 화면에 보이지 않는 요소들까지 계속 쌓여서 메모리를 많이 차지하는 문제가 보였습니다. 이를 해결하기 위해 **화면에 보이는 10~20개만 실제로 그려주는 기술** 을 찾아보았습니다.
* **비유 및 트레이드오프:**
* 마트에 있는 상품 1만 개를 전부 진열대에 꺼내놓는 대신, **'손님이 지금 보고 있는 칸에만 물건을 채워 넣는 방식'** 입니다.
* 이렇게 하면 진열대(메모리)는 가볍고 쾌적해지지만, 안내원(스크린 리더)이나 물건 찾기(Ctrl+F) 기능이 전체 물건을 훑어볼 수 없다는 치명적인 단점이 생깁니다. 진열대에 꺼내져 있지 않은 물건은 "없다"고 인식하기 때문입니다. 이번 프로젝트에서는 속도보다 **'누구나 물건을 찾을 수 있는 접근성'** 이 더 중요하다고 판단하여 적용을 보류했습니다.


* **앞으로의 계획:** 접근성을 해치지 않으면서도 화면 요소를 효율적으로 관리할 수 있는 방법을 더 깊이 연구해서, 성능과 접근성 두 마리 토끼를 모두 잡는 목록을 구현해보고 싶습니다.

---
</details>

<details>
<summary><h2>크리스마스 : 오버엔지니어링</h2></summary>

## 코드 가독성 개선: 호이스팅을 활용한 구조 변경

### 개요

핵심 목표는 **중요한 로직을 파일의 최상단에 배치하는 것** 입니다.

기존 코드에서는 헬퍼 함수들이 메인 로직보다 위에 작성되어 있어, 코드를 읽을 때 세부 구현 사항부터 마주해야 하는 흐름이었습니다. 자바스크립트의 **호이스팅** 특성을 활용하여 메인 비즈니스 로직을 최상단으로 올리고, 세부 구현 함수들은 하단으로 배치하여 가독성을 높였습니다.

### 변경 이유

**1. 위에서 아래로 읽히는 자연스러운 흐름**
신문 기사를 읽을 때 헤드라인과 핵심 내용을 먼저 보고 세부 사항을 나중에 읽는 것처럼, 코드도 핵심 로직이 먼저 보여야 합니다.

* **기존:** `fill2`, `parseHnM` 등 보조 함수가 먼저 등장하여 메인 로직인 `parseSchedule`을 찾기 위해 스크롤을 내려야 했습니다.
* **변경 후:** `parseSchedule` 함수가 가장 먼저 등장하여 코드의 목적을 바로 파악할 수 있습니다.

**2. 헬퍼 함수의 위치 재조정**
`getTimeRange`나 정규식 생성 같은 기능은 메인 로직을 돕는 보조 역할을 합니다. 이러한 세부 구현 내용을 하단으로 이동시켜, 코드를 읽는 사람이 흐름을 방해받지 않도록 개선했습니다.

### 핵심 개념: 호이스팅

이러한 구조 변경을 가능하게 한 것은 자바스크립트의 **호이스팅** 기능입니다.

호이스팅이란 자바스크립트 엔진이 코드를 실행하기 전, 변수와 함수의 선언을 메모리에 미리 등록하는 과정을 말합니다. 특히 `function` 키워드로 선언된 함수는 선언문 자체가 온전하게 끌어올려지므로, **함수가 정의된 위치보다 위에서 호출하는 것이 가능합니다.**

### 변경된 패턴

**1. 화살표 함수에서 함수 선언문으로 변경**
`const`로 선언된 화살표 함수는 선언 라인에 도달하기 전에는 사용할 수 없습니다. 이를 `function` 선언문으로 변경하여, 파일 내 어느 위치에서든 자유롭게 호출할 수 있도록 했습니다.

```typescript
// 기존: const는 호이스팅 되지만 초기화 전에는 사용 불가 (일시적 사각지대)
const fill2 = (n: number) => { ... }

// 변경: function은 선언과 동시에 사용 가능
export function fill2(n: number) { ... }

```

**2. 정규식 변수의 함수화**
정규식 변수(`const reg = ...`) 또한 호이스팅의 제약을 받으므로 아래로 내릴 수 없었습니다. 이를 **정규식을 반환하는 함수**로 감싸서 호이스팅이 가능하도록 처리했습니다. 덕분에 지엽적인 정규식 패턴도 메인 로직의 시야에서 분리할 수 있었습니다.

### 코드 비교

**변경 전**
세부 함수들이 먼저 나와서 메인 로직을 한눈에 파악하기 어렵습니다.

```typescript
const getTimeRange = (value) => { ... } // 세부 구현
const reg = /^.../; // 세부 변수

export const parseSchedule = (schedule) => { // 메인 로직
   // ...
}

```

**변경 후**
메인 로직이 바로 보이며, 문맥 흐름이 자연스럽습니다.

```typescript
// 메인 로직이 가장 먼저 등장
export function parseSchedule(schedule: string) {
  const reg = getScheduleRegex(); // 아래에 있는 함수를 위에서 호출 (호이스팅)
  const range = getTimeRange(...);
  // ...
}

// 세부 구현 내용은 아래로 이동
function getScheduleRegex() { return /^.../; }
function getTimeRange(value) { ... }

```

### 오버엔지니어링 후기

이 코드는 자바스크립트 엔진이 코드를 해석하고 메모리에 올리는 동작 원리를 활용한 패턴입니다.
함수가 정의되기 전에 호출되는 것처럼 보여 낯설 수 있지만, 이 패턴을 통해 **중요한 것을 먼저 보여주는 방식** 지양해야 할 호스팅을 활용하여 엔진 실행 흐름 + 개발자 인지 흐름을 일치시킬 수 있게 됐습니다.

---
## 2. 성능 최적화: Context 직렬화 연산 개선

### 개요

핵심 목표는 **렌더링 경로에서 불필요한 직렬화 연산을 제거하는 것** 입니다.

`ScheduleContext`에서 키 배열의 변경을 감지하기 위해 사용하던 `JSON.stringify`는 매 렌더링마다 O(N)의 비용을 발생시킵니다. 이를 `useRef`와 얕은 비교 기법으로 대체하여 성능을 최적화했습니다.

### 변경 이유

**1. 렌더링 비용 절감**
`JSON.stringify`는 객체를 문자열로 변환하기 위해 전체를 순회해야 하는 무거운 작업입니다. 단순한 ID 목록 비교를 위해 매번 이 비용을 지불하는 것은 비효율적입니다.

* **기존:** 렌더링마다 수백, 수천 개의 키를 가진 객체를 문자열로 변환.
* **변경 후:** 문자열 변환 없이 배열의 길이와 요소만 빠르게 비교.

**2. 안정적인 참조 유지**
불필요한 연산을 제거함과 동시에, 값이 실제로 변경되지 않았을 때는 이전 참조(Reference)를 그대로 유지하여 하위 컴포넌트의 리렌더링을 방지합니다.

### 핵심 개념: 참조 동등성 (Reference Equality)

리액트의 리렌더링을 결정하는 핵심은 **"참조가 바뀌었는가?"** 입니다.
우리는 `useRef`를 사용하여 이전 상태를 메모리에 보존하고, 새로운 데이터와 **직접 비교** 를 수행합니다. 이를 통해 리액트의 의존성 배열 검사가 문자열이 아닌, 우리가 제어한 참조 값을 바라보게 만듭니다.

### 변경된 패턴

**usePreservedTableIds 커스텀 훅 도입**
매번 새로운 문자열을 생성하는 대신, 변화가 있을 때만 `ref.current`를 업데이트하는 훅을 구현했습니다.

```typescript
// 기존: 매번 O(N) 문자열 생성 비용 발생
useMemo(() => keys, [JSON.stringify(keys)])

// 변경: O(1) 길이 체크 + O(N) 단순 순회 (문자열 변환보다 훨씬 빠름)
const usePreservedTableIds = (map) => {
  const idsRef = useRef([]);
  // ... 길이 및 요소 비교 로직 ...
  if (changed) idsRef.current = newIds;
  return idsRef.current;
}

```

### 코드 비교

**변경 전**
편리하지만 비용이 바싼 패턴입니다.

```typescript
const tableIds = useMemo(() => Object.keys(schedulesMap), [
  JSON.stringify(Object.keys(schedulesMap)) // 렌더링마다 O(N) 발생
]);

```

**변경 후**
메모리를 직접 제어하여 성능을 극대화한 패턴입니다.

```typescript
// 내부에서 useRef로 참조를 관리하여 불필요한 연산 차단
const tableIds = usePreservedTableIds(schedulesMap);

// 의존성 배열에는 참조값만 전달
const idsValue = useMemo(() => ({ tableIds }), [tableIds]);

```

### 오버엔지니어링 후기

리액트가 제공하는 `deps` 배열에만 의존하지 않고, 직접 변경 감지 로직을 구현했습니다.

이는 "편리함(JSON.stringify)" 뒤에 숨은 성능 비용을 찾아내고, **자료구조적 접근**으로 해결한 최적화를 시도해봤습니다. 데이터가 늘어날수록 이 최적화의 효과를 많이 볼 수 있을거라고 생각합니다.

---

## 3. 알고리즘 최적화: 비트마스크 연산

### 개요

핵심 목표는 **검색 필터링 속도를 획기적으로 단축시키는 것** 입니다.

기존에는 배열 메서드(`includes`, `some`)를 사용하여 O(N * M)의 비용이 들었으나, 이를 **비트마스크(Bitmask)** 알고리즘으로 대체하여 O(1)의 비트 연산으로 최적화했습니다.

### 변경 이유

**1. 대량 데이터 처리 속도 향상**
수천 개의 강의 데이터와 복잡한 요일/시간 조건을 비교할 때, 반복문 기반의 탐색은 CPU 사이클을 많이 소모합니다.

* **기존:** 루프를 돌며 배열 안에 값이 있는지 하나하나 확인.
* **변경 후:** 단 한 번의 비트 연산(`&`)으로 겹침 여부 즉시 판단.

**2. 공간과 시간의 트레이드오프**
`scheduleMask`라는 추가적인 메모리 공간(BigInt)을 사용하여, 실행 시간(Time Complexity)을 극한으로 줄이는 전략을 취했습니다.

### 핵심 개념: 비트마스크 (Bitmask)

시간표의 요일과 교시를 **이진수 비트** 로 1:1 매핑하는 기법입니다.
예를 들어 `월요일 1교시`를 `0번째 비트`, `화요일 1교시`를 `16번째 비트`로 설정합니다. 이렇게 하면 복잡한 시간표가 하나의 거대한 정수(`BigInt`)로 표현됩니다.

### 변경된 패턴

**배열 순회 → 비트 연산자 변경**

```typescript
// 기존: 배열 순회 (느림)
if (lectures.some(l => days.includes(l.day))) ...

// 변경: 비트 AND 연산 (매우 빠름)
// 두 비트마스크를 AND(&) 연산했을 때 0이 아니면 겹치는 시간이 존재함
if ((lecture.scheduleMask & searchMask) !== 0n) ...

```

### 코드 비교

**변경 전**
가독성은 좋지만 데이터가 많아지면 느려지는 로직입니다.

```typescript
// SearchDialog.tsx
lectures.filter(lecture => {
  // 중첩 루프 발생
  return lecture.schedules.some(s => days.includes(s.day));
})

```

**변경 후**
CPU가 가장 좋아하는 방식의 연산입니다.

```typescript
// utils.ts (미리 계산)
lecture.scheduleMask = getScheduleMask(lecture.schedule);

// SearchDialog.tsx
lectures.filter(lecture => {
  // O(1) 비트 연산
  return (lecture.scheduleMask & dayMask) !== 0n;
})

```

### 오버엔지니어링 후기

프론트엔드에서 잘 도입하지 않는 **비트마스크** 를 찾아보고 도입했습니다.
`BigInt`를 활용해 32비트의 한계를 넘어선 비트 공간을 확보하고, 이를 통해 수천 번의 배열 순회를 단 몇 번의 CPU 사이클로 압축했습니다.
비트연산을 통해 더 빠른 계산이 가능하게 됐습니다.

---
</details>
<details>
<summary><h2>🚧 시간없어서 넘어간 거슬리는 이슈</h2></summary>

### 1. 웹 접근성(A11y) 경고: Form ID 중복 및 라벨 미매칭

현재 브라우저 콘솔에 다음과 같은 경고가 출력되는 것을 인지하고 있습니다.

> 1. `The label's for attribute doesn't match any element id`
> 2. `Multiple form field elements in the same form have the same id attribute value`

**원인**
- 반복 렌더링되는 컴포넌트 내부의 `input` 요소들에 고정된 `id`가 부여되어 발생한 문제입니다.
- 이로 인해 스크린 리더 인식 불가 및 자동완성 기능에 제약이 생길 수 있습니다.

**해결 계획 (To-Do)**
- 여행 일정으로 인해 부득이하게 이번 PR에는 수정 사항을 반영하지 못했습니다.
- **여행 복귀 후**, 리액트의 **`useId` 훅**을 도입하거나 유니크 ID 생성 로직을 적용하여 접근성 문제를 최우선으로 리팩토링 해보려고 합니다.

---
</details>

### 기술적 성장

#### memo는 만능이 아니다

* **“memo를 쓴다고 무조건 빨라지는 건 아니구나”**
  처음에는 `React.memo`만 감싸면 렌더링이 최적화될 줄 알았습니다.
  하지만 프로파일러로 확인해 보니 여전히 리렌더링이 발생하고 있었고,
  그 원인이 **참조값(Reference)이 매번 바뀌기 때문**이라는 사실을 알게 되었습니다.

  이 과정을 통해 `useCallback`과 `useMemo`는 단순한 문법이 아니라,
  불필요한 리렌더링을 막기 위한 **렌더링 방어막**이라는 점을 깊이 이해하게 되었습니다.

---

#### 메인 스레드를 쉬게 해주기

* **“메인 스레드를 블로킹하지 않아야 사용자는 렉을 느끼지 않는다”**
  이전에는 코드가 순서대로 실행되는 것만을 고려했지만,
  이번 작업을 통해 메인 스레드 점유 여부가 체감 성능에 직접적인 영향을 준다는 사실을 배웠습니다.

  API를 병렬(`Promise.all`)로 호출하고,
  무거운 데이터 가공을 렌더링 중이 아닌 **데이터 로딩 시점** 에 미리 처리하는
  전처리(Pre-calculation) 방식으로 변경하자 체감 속도가 확연히 개선되는 경험을 했습니다.

---

#### 리액트와 DOM의 타이밍 맞추기

* **“리액트 상태와 실제 DOM 생성 시점은 다를 수 있다”**
  무한 스크롤 구현 과정에서 `useRef`에 값이 할당되어도 리렌더링이 발생하지 않아
  `IntersectionObserver`가 연결되지 않는 버그를 경험했습니다.

  이를 통해 DOM이 실제로 마운트되는 타이밍과
  리액트의 상태 업데이트 타이밍이 다를 수 있다는 점을 이해하게 되었고,
  **Callback Ref 패턴**을 사용해 해당 문제를 안정적으로 해결할 수 있었습니다.

---

### 코드 품질

#### 코드가 읽기 좋아야 성능도 잡힌다

* **“구조가 곧 성능이다”**
  `ScheduleTable` 컴포넌트가 지나치게 비대해져 수정이 어려운 상태였습니다.
  이를 **변하지 않는 배경(GridBackground)** 과
  **자주 변하는 강의(Schedule)** 컴포넌트로 분리하면서
  코드 가독성과 렌더링 성능이 동시에 개선되는 경험을 했습니다.

  이 과정을 통해 **관심사 분리와 구조 설계가 곧 성능 최적화로 이어진다** 는 점을 체감했습니다.

---

#### 상태는 필요한 곳에만 두기

* **“전역 상태는 편하지만, 공짜는 아니다”**
  처음에는 `DndContext`를 최상위에 두었지만,
  드래그 이벤트 발생 시 모든 테이블이 리렌더링되는 문제가 있었습니다.

  이를 각 테이블 내부로 이동해 상태를 **격리** 하자
  불필요한 렌더링이 제거되었고 체감 성능도 즉시 개선되었습니다.

  이를 통해 **상태는 사용하는 가장 가까운 위치에 둬야 한다** 는 원칙을 명확히 이해하게 되었습니다.

---

#### 복잡한 조건문 정리하기

* **“읽기 쉬운 코드가 결국 빠르다”**
  검색 필터링 로직이 여러 `&&` 조건으로 길게 연결되어 있어
  가독성과 디버깅이 모두 어려운 상태였습니다.

  이를 `if (!조건) return false` 형태의
  **Guard Clause 패턴**으로 변경하니
  코드 흐름이 명확해지고, 조건 불일치 시 조기 종료되어
  연산 비용까지 자연스럽게 줄일 수 있었습니다.

---

### 학습 효과 분석

#### 기술 선택에는 항상 트레이드오프가 따른다

* **“좋은 기술도 상황에 맞지 않으면 독이 된다”**
  가상화는 성능 면에서는 강력하지만,
  스크린 리더가 콘텐츠를 읽지 못해 **접근성을 해친다**는 문제를 직접 확인했습니다.

  이를 통해 무조건 최신 기술을 도입하는 것이 정답이 아니라,
  **서비스의 핵심 가치와 사용자 경험을 먼저 고려해야 한다**는 점을 배웠습니다.

---

#### 실무 적용에 대한 자신감

* **“지금 당장 실무에 써먹을 수 있는 최적화들”**
  API 병렬 호출, 렌더링 경계 분리, 메모이제이션 전략 등은
  실제 프로젝트에서도 즉각적인 성능 개선 효과를 낼 수 있는 방법이라는 확신이 들었습니다.

---

#### 더 공부해보고 싶은 것들

* **“다음 단계의 성능 최적화”**
  이번에는 트레이드오프 문제로 도입하지 못했지만,
  **Web Worker** 패턴은
  대규모 데이터 처리 환경에서 꼭 다시 도전해보고 싶은 주제입니다.


### 과제 피드백
<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

## 리뷰 받고 싶은 내용


#### 1. React 19(React Compiler)와 수동 최적화의 미래

> **배경:** 이번 과제에서 `useMemo`, `useCallback`을 사용하여 리렌더링을 막는 데 많은 시간을 쏟았습니다.

* **질문:**
최근 React 19와 **React Compiler(구 React Forget)** 소식을 접했습니다. 컴파일러가 도입되면 자동으로 메모이제이션이 처리되어 개발자가 수동으로 `useMemo`나 `memo`를 쓸 일이 없어진다고 하던데요.
**그렇다면 지금 제가 연습한 수동 최적화 기술들은 앞으로 레거시가 되는 걸까요?** 아니면 컴파일러 시대에도 여전히 개발자가 렌더링 파이프라인을 이해하고 수동으로 제어해야 할 영역이 남을까요? 주니어로서 어떤 스탠스를 취해야 할지 궁금합니다.

#### 2. 실무에서의 '최적화와 개발공수의 우선순위

> **배경:** 최적화를 하다 보니 욕심이 생겨서 끝도 없이 파고들게 되었습니다.

* **질문:**
이번에 최적화를 진행하다 보니 1ms라도 더 줄이고 싶어서 밤을 새우게 되더라고요. 하지만 회사에서는 리소스가 한정되어 있으니 마냥 최적화만 할 순 없을 것 같습니다.
코치님께서는 실무에서 성능 개선 작업을 하실 때 **'이 정도면 충분하다'라고 판단하고 다음 기능 개발로 넘어가는 정량적/정성적 기준**이 있으신가요? (예: Lighthouse 점수 90점, 혹은 하위 10% 기기에서의 프레임 방어 등)



#### 3. 현업 경험 부재와 심화 과제 경험의 이력서 활용 전략

> **배경:** 현재 개발 직무를 떠나 있어 실무에서의 대규모 트래픽 처리나 운영 배포 경험이 부족한 상태입니다. 다시 개발자로 돌아가고 싶은 열망이 크지만, 이력서에 적을 '실무 트러블슈팅' 경험이 없어 위축되곤 합니다.

* **질문:**
이번 항해 과제를 수행하면서 일반적인 최적화(메모이제이션 등) **비트마스크 알고리즘 도입, 렌더링 참조 최적화, 호이스팅 구조 개선** 등 기술적으로 깊이 파고드는 경험을 했습니다.
현업 프로젝트가 아닌 **개인/부트캠프 과제에서 수행한 이러한 기술적 시도와 PR 내용**을 이력서에 메인으로 녹여내도 신입/주니어 지원 시 충분히 경쟁력이 있을까요?
실무 경험이 없는 상태에서 이러한 경험을 어떤 관점으로 어필해야 면접관에게 긍정적인 평가를 받을 수 있을지 조언 부탁드립니다.

---
10주간에 항해의 마지막 과제라고 하니까 크리스마스임에도 과제에 미련이남네요...
양질의 과제와 멘토링을 통해 10주전의 저보다 조금은 나아졌음을  느끼고 코치님들에게 감사합마음이 듭니다.
내년에는 같은 프론트엔드 개발씬에서 개발자로 커리어를 다시 시작할 수 있는 한해면 좋겠네요.

항해 끝!

