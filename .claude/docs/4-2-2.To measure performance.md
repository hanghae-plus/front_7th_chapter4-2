# 참고자료

[Bora Lee on LinkedIn: [프론트엔드 성능 모니터링(측정편) - 1] 현대 경영학의 아버지 피터 드러커는 “측정할 수 없으면 관리할 수 없고, 관리할 수…](https://www.linkedin.com/posts/learner-bora_프론트엔드-성능-모니터링측정편-1-현대-경영학의-아버지-피터-activity-7226187837338009600-FtBz?utm_source=share&utm_medium=member_desktop)

[Bora Lee on LinkedIn: [프론트엔드 성능 모니터링(측정편) - 2] 앞서 소개한 PageSpeed Insights의 경우 여러 가지 장점이 있으나, 실제…](https://www.linkedin.com/posts/learner-bora_프론트엔드-성능-모니터링측정편-2-앞서-소개한-pagespeed-activity-7226655481723858944-CCBz?utm_source=share&utm_medium=member_desktop)

[Core Web Vitals - Chrome Web Store](https://chromewebstore.google.com/detail/core-web-vitals/adeniimnihmbpgpbljmnohjpoolmgabj)

[웹 바이탈 확장 프로그램을 사용하여 코어 웹 바이탈 문제 디버그  |  Articles  |  web.dev](https://web.dev/articles/debug-cwvs-with-web-vitals-extension?hl=ko)

[](https://developer.mozilla.org/en-US/docs/Web/API/Performance_API/Using_the_Performance_API)

[Profiler – React](https://react.dev/reference/react/Profiler)

[실적 패널: 웹사이트 실적 분석  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/performance/overview?hl=ko)

[성능 최적화](https://ui.toast.com/fe-guide/ko_PERFORMANCE)

[](https://www.webpagetest.org/)

[커스텀 측정항목  |  Articles  |  web.dev](https://web.dev/articles/custom-metrics?hl=ko)

# 1. 프론트엔드 성능의 종류와 측정 방법

[사용자 중심 성능 측정항목  |  Articles  |  web.dev](https://web.dev/articles/user-centric-performance-metrics?hl=ko)

## (1) 측정할 수 있는 성능의 종류

### 1) 로딩 성능

- **First Contentful Paint (FCP):** 페이지의 첫 번째 콘텐츠(텍스트, 이미지 등)가 렌더링되는 시간을 측정합니다. 사용자가 페이지가 **로딩되었음을 인지할 수 있는 첫 시점**입니다.
  [First Contentful Paint (FCP)  |  Articles  |  web.dev](https://web.dev/articles/fcp?hl=ko)
- **Largest Contentful Paint (LCP):** 가장 큰 콘텐츠가 렌더링되는 시간으로, 사용자가 페이지가 **거의 로드되었다고 느끼는 시점**을 반영합니다.
  [Largest Contentful Paint (LCP)  |  Articles  |  web.dev](https://web.dev/articles/lcp?hl=ko)
- **Interaction to Next Paint(INP)**: INP는 사용자가 페이지와 함께 한 모든 **상호작용**의 지연 시간을 관찰하고 모든 상호작용 또는 거의 모든 상호작용이 아래에 있는 단일 값을 보고합니다.
  [Interaction to Next Paint(다음 페인트와의 상호작용)(INP)  |  Articles  |  web.dev](https://web.dev/articles/inp?hl=ko)
- **Time to Interactive (TTI):** 페이지가 완전히 상호작용 가능해지는 시점까지의 시간입니다. 모든 주요 리소스가 로드되고 이벤트 핸들러가 설정된 시점입니다.
  [상호작용 시작 시간 (TTI)  |  Articles  |  web.dev](https://web.dev/articles/tti?hl=ko)
- **Total Blocking Time (TBT):** 페이지 로딩 중 사용자가 인터랙션을 시도할 때 발생하는 지연 시간을 측정합니다.
  [총 차단 시간 (TBT)  |  Articles  |  web.dev](https://web.dev/articles/tbt?hl=ko)
- **Speed Index:** 페이지의 시각적 콘텐츠가 얼마나 빨리 완전히 로드되는지를 측정하는 지표입니다.
  [속도 색인  |  Lighthouse  |  Chrome for Developers](https://developer.chrome.com/docs/lighthouse/performance/speed-index?hl=ko)

### 2) 렌더링 성능

- **Frame Rate (FPS):** 애니메이션이나 스크롤 시의 부드러움을 나타내며, 초당 프레임 수를 측정합니다.
- **Cumulative Layout Shift (CLS):** 페이지가 로드되는 동안 발생하는 예상치 못한 레이아웃 변경의 빈도를 측정합니다. 사용자가 예상치 못한 움직임을 경험하게 되는 경우가 줄어들도록 도와줍니다.
  [Cumulative Layout Shift (CLS)  |  Articles  |  web.dev](https://web.dev/articles/cls?hl=ko)
- **Long Tasks:** 메인 스레드에서 실행되는 긴 작업(50ms 이상)으로 인해 페이지 응답성이 저하되는 시간을 측정합니다.
  [장기 작업 최적화  |  Articles  |  web.dev](https://web.dev/articles/optimize-long-tasks?hl=ko)

### 3) 자바스크립트 성능

- **Execution Time:** 자바스크립트 코드가 실행되는 시간을 측정하여 성능을 분석합니다.
- **Memory Usage:** 자바스크립트 코드가 사용하고 있는 메모리의 양을 측정합니다. 메모리 누수가 없는지, 효율적으로 메모리가 사용되고 있는지를 파악할 수 있습니다.
  [할당 프로파일러 도구 사용 방법  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory-problems/allocation-profiler?hl=ko)
  [measureUserAgentSpecificMemory()로 웹페이지의 총 메모리 사용량을 모니터링합니다.  |  Articles  |  web.dev](https://web.dev/articles/monitor-total-page-memory-usage?hl=ko)
  [JavaScript의 메모리 관리 - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_management)
  [당신이 모르는 자바스크립트의 메모리 누수의 비밀](https://ui.toast.com/weekly-pick/ko_20210611)
- **Garbage Collection 빈도 및 지속 시간:** 가비지 컬렉터가 메모리를 정리하는 빈도와 그 과정에서의 시간 소모를 측정합니다.
  [가비지 컬렉션](https://ko.javascript.info/garbage-collection)

### 4) 네트워크 성능

- **Resource Size:** 페이지에 필요한 리소스(이미지, CSS, JS 파일 등)의 크기를 측정합니다. 파일 크기가 클수록 로드 시간이 증가할 수 있습니다.
- **Number of Requests:** 페이지 로딩 시 발생하는 네트워크 요청 수를 측정합니다. 요청 수가 많을수록 페이지 로드 속도가 느려질 수 있습니다.
- **Time to First Byte (TTFB):** 사용자가 요청을 보낸 후, 서버에서 첫 번째 바이트를 받기까지 걸리는 시간을 측정합니다. 서버 응답 시간을 개선하는 데 중요한 지표입니다.

## (2) 성능을 측정하는 도구

### 1) 브라우저 내장 도구

- **Chrome DevTools**
  - **Performance 탭:** 전체 페이지 성능을 분석할 수 있으며, 로딩 성능, 자바스크립트 실행 시간, 렌더링 성능 등을 상세히 살펴볼 수 있습니다.
    [실적 패널: 웹사이트 실적 분석  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/performance/overview?hl=ko)
  - **Network 탭:** 페이지의 모든 네트워크 요청을 분석하여 로딩 성능을 최적화할 수 있습니다.
    [네트워크 패널: 네트워크 부하 및 리소스 분석  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/network/overview?hl=ko)
  - **Memory 탭:** 메모리 사용량과 가비지 컬렉션을 분석하여 자바스크립트 성능을 최적화할 수 있습니다.
    [메모리 패널 개요  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ko)
- **Lighthouse:** 웹 페이지의 성능, 접근성, SEO 등을 종합적으로 평가하는 도구입니다. 자동화된 보고서를 통해 성능을 개선할 수 있는 방법을 제시합니다.
  [개요  |  Lighthouse  |  Chrome for Developers](https://developer.chrome.com/docs/lighthouse/overview?hl=ko)

### 2) 외부 성능 측정 도구

- **WebPageTest:** 웹 페이지의 성능을 다양한 환경에서 테스트할 수 있는 도구로, 상세한 성능 분석 결과를 제공합니다.
  [](https://www.webpagetest.org/)
  [웹페이지 성능/속도측정 - www.webpagetest.org](https://test-myid.tistory.com/4)
- **Google Search Console:** 사이트의 기본 성능 이외에 검색 성능등을 모니터링하고 최적화 하는데 사용하는 무료도구로, 웹사이트 소유자만 접근 가능합니다. 성능 이외에도 SEO 최적화를 위한 모니터링과 수단을 설명해줍니다.
  [](https://search.google.com/search-console/welcome)
- **GTmetrix:** 페이지 로딩 속도와 관련된 다양한 지표를 제공하며, 개선 사항을 제안해 줍니다.
  [GTmetrix | Website Performance Testing and Monitoring](https://gtmetrix.com/)
  [내 웹사이트 로딩 속도 측정 체크 방법1 - gtmetrix.com - 사이트 최적화 하기](https://blog.naver.com/myappkorea/222226836260)
- **PageSpeed Insights:** Google에서 제공하는 도구로, 모바일과 데스크톱 환경에서의 페이지 성능을 평가합니다.
  [PageSpeed Insights](https://pagespeed.web.dev/?hl=ko)
  [맞춤형 풀스택 옵저버빌리티 및 보안 | Datadog](https://www.datadoghq.com/ko/dg/monitor/personalized-demo-request/?utm_source=google&utm_medium=paid-search&utm_campaign=dg-brand-apac-ko-brand&utm_keyword=datadog&utm_matchtype=p&igaag=158938765812&igaat=&igacm=20569180520&igacr=674510540631&igakw=datadog&igamt=p&igant=g&utm_campaignid=20569180520&utm_adgroupid=158938765812&gad_source=1)
  [PageSpeed Insights 정보  |  Google for Developers](https://developers.google.com/speed/docs/insights/v5/about?hl=ko)

### 3) 성능 모니터링 서비스

- **New Relic:** 애플리케이션 성능을 실시간으로 모니터링하고, 문제 발생 시 알림을 제공합니다. 서버 성능까지 포함하여 전체적인 성능 분석이 가능합니다.
  [Monitor, Debug and Improve Your Entire Stack](https://newrelic.com/)
  [여기어때 서비스 모니터링 : New Relic 이야기](https://techblog.gccompany.co.kr/여기어때-서비스-모니터링-new-relic-이야기-dad36583dec4)
- **Datadog:** 애플리케이션, 서버, 데이터베이스 등 다양한 환경의 성능을 모니터링할 수 있으며, 통합된 대시보드를 제공합니다.
  [Datadog 소개](https://velog.io/@kameals/system-monitoring-datadog-intro)
- **Sentry:** 자바스크립트 오류 추적 및 성능 모니터링에 특화된 도구로, 버그와 성능 문제를 실시간으로 파악할 수 있습니다.
  [Application Performance Monitoring & Error Tracking Software](https://sentry.io/welcome/)
  [Sentry로 우아하게 프론트엔드 에러 추적하기 | 카카오페이 기술 블로그](https://tech.kakaopay.com/post/frontend-sentry-monitoring/)
  [Sentry로 사내 에러 로그 수집 시스템 구축하기](https://engineering.linecorp.com/ko/blog/log-collection-system-sentry-on-premise)
  [프론트엔드 에러 로그 시스템 Sentry 적용기](https://urbanbase.github.io/dev/2021/03/04/Sentry.html)
- Azure Application Insights: Microsoft Azure 클라우드 플랫폼의 일부로, 웹 애플리케이션의 성능과 사용량을 모니터링하고 분석하는 도구입니다. 상대적으로 간단한 설정으로 설치 가능하고, Azure 인프라를 사용하는 경우 데이터 적재 등의 연동에 유리합니다.
  [Application Insights 개요 - Azure Monitor](https://learn.microsoft.com/ko-kr/azure/azure-monitor/app/app-insights-overview)

## (3) 코드를 통해서 직접 성능을 측정해보기

### 1) Web API를 이용한 성능 측정

```jsx
// Performance API를 사용한 시간 측정
const startTime = performance.now();

// 측정하고자 하는 작업 수행
heavyComputation();

const endTime = performance.now();
console.log(`작업 실행 시간: ${endTime - startTime} 밀리초`);

// Navigation Timing API를 사용한 페이지 로드 시간 측정
window.addEventListener("load", () => {
  const navigationTiming = performance.getEntriesByType("navigation")[0];
  console.log(
    `페이지 로드 시간: ${navigationTiming.loadEventEnd - navigationTiming.navigationStart} 밀리초`
  );
});
```

```bash
# 결과물 예시
작업 실행 시간: 543.2 밀리초
페이지 로드 시간: 1245.7 밀리초
```

### 2) Core Web Vitals 측정

```jsx
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === "largest-contentful-paint") {
      console.log(`LCP: ${entry.startTime}`);
    }
    if (entry.entryType === "layout-shift") {
      console.log(`CLS: ${entry.value}`);
    }
    if (entry.entryType === "first-input") {
      console.log(`FID: ${entry.processingStart - entry.startTime}`);
    }
  }
});

observer.observe({ entryTypes: ["largest-contentful-paint", "layout-shift", "first-input"] });
```

```bash
# 결과물 예시
LCP: 2345.6
CLS: 0.1
FID: 95.3
```

### 3) React 성능 프로파일링

```jsx
import React, { Profiler } from "react";

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime,
  interactions
) {
  console.log(`컴포넌트 ${id}의 렌더링 시간: ${actualDuration}`);
}

function MyComponent() {
  return (
    <Profiler id='MyComponent' onRender={onRenderCallback}>
      {/* 컴포넌트 내용 */}
    </Profiler>
  );
}
```

```bash
# 결과물 예시
컴포넌트 MyComponent의 렌더링 시간: 78.5
```
